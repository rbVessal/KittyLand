using UnityEngine;
using System.Collections;
//including some .NET for dynamic arrays called List in C#
using System.Collections.Generic;


[RequireComponent(typeof(Steering))]
[RequireComponent(typeof(CharacterController))]
[RequireComponent(typeof(Dimensions))]


public class LostKitten : MonoBehaviour
{
	private WayPointNode target  = null;

	// These weights will be exposed in the Inspector window
	public float seekWt = 1.0f;
    public float alignmentWeight = 2.0f;
	public float avoidWt = 30.0f;
	private const float MINIMUM_DISTANCE = 100.0f;
	private const float PLAYER_STARTING_POSITION_OFFSET = 40.0f;
	private float avoidDist;
	
	// Each vehicle contains a CharacterController which
	// makes it easier to deal with the relationship between
	// movement initiated by the character and the forces
	// generated by contact with the terrain & other game objects.
	private CharacterController characterController = null;
	
	// the steering component implements the basic steering functions
	private Steering steering = null;
	private Vector3 seekBehindPointSteeringForce;
	private Vector3 avoidObstacleSteeringForce;
	
	// movement variables
	private float gravity = 150.0f;
	private Vector3 moveDirection;

	//steering variable
	private Vector3 steeringForce;
	
	//reference to an array of obstacles
	private GameObject[] obstacles;

    //Reference to first waypoint
    public WayPointNode firstWayPointNode;

    //Starting position for lost kitten
	private Vector3 startPos;

	private Player player;

    //Flag to indicate it has been captured by player
    private bool capturedByPlayer;
	
	//Flag to indicate that the lost kitten has started searching
	//for the first way point
	private bool isSearchingForWayPoint;
	
	//A way to access the cat out the followers array easily
	private int catNumber;
	
	//Each lost kitten has a behind point, so that the other
	//lost kittens can follow each other
	public GameObject BehindPoint;
	private float BehindPointRadius;
	private const float BEHIND_POINT_RADIUS_OFFSET = 20.0f;
	
	//A follower who follows one of the lost kittens
	private LostKitten catFollowerLeader;
	
	//Flag for turning on and off the visibility of the lost kitten shell
	private bool isVisible;
	//Flag for indicating the kitty has been returned to the mom cat
	private bool returnedToMomCat;
	
	//Reference for the mom cat
	private GameObject momCat;

    //Setters and getters
    public bool CapturedByPlayer
    {
        get { return capturedByPlayer; }
        set { capturedByPlayer = value; }
    }

    public Steering Steering
    {
        get { return steering; }
    }
	
	public int CatNumber
	{
		get {return catNumber;}
		set {catNumber = value;}
	}
	
	public LostKitten CatFollowerLeader
	{
		get {return catFollowerLeader;}
		set {if(catFollowerLeader == null)catFollowerLeader = value;}
	}
	
	public bool IsSearchingForWayPoint
	{
		set {isSearchingForWayPoint = value;}
	}
	
	public bool ReturnedToMomCat
	{
		set{returnedToMomCat = value;}
	}
	
	public void Start ()
	{
		//get component reference
		characterController = gameObject.GetComponent<CharacterController>();
		steering = gameObject.GetComponent<Steering>();
		moveDirection = transform.forward;
		steering.maxForce = 90;
        // tags behave as layers, but are called tags (and can't be used for masks)
		obstacles = GameObject.FindGameObjectsWithTag ("Obstacle");
		avoidDist = obstacles[0].GetComponent<Dimensions>().Radius + 10;
		
		//Find the player
		player = GameObject.FindGameObjectWithTag("Player").GetComponent<Player>();
		//Find the mom cat
		momCat = GameObject.FindGameObjectWithTag("Mom Cat");
		
		//Assign the target to be the first way point
        target = firstWayPointNode;
		
		//Set up everything else
		startPos = transform.position;
        capturedByPlayer = false;
		BehindPointRadius = BehindPoint.GetComponent<SphereCollider>().radius + BEHIND_POINT_RADIUS_OFFSET;
		isSearchingForWayPoint = false;
		returnedToMomCat = false;
		
		//Make the lost kitten not visible at first
		Visibility(false);
		
		
	}
	
	//Turn on or off visibility
	public void Visibility(bool visibility)
	{
		this.transform.Find("shell").renderer.enabled = visibility;
		isVisible = visibility;
	}
	
	//Restart the seeker to the starting position if it collides with 
	//the target
	private void OnTriggerEnter(Collider collider)
	{
        if (!capturedByPlayer)
        {
            //If collided with a waypoint, then seek the next waypoint
            if (collider.gameObject.tag == "WayPoint")
            {
                //If it is the last waypoint, then start both
                //the player and the lost kitten back at the start position
                if (collider.gameObject.GetComponent<WayPointNode>().nextWayPointNode == null)
                {
                    Reset();
                }
                else
                {
                    
                    target = target.nextWayPointNode;
                }
            }
        }
	}
	
	//Reset both the lost kitten and the player 
	//with his or her follower lost kittens
	//if the lost kitten reaches the last way point in the 
	//path.
    private void Reset()
    {
        ResetLostKitten();
		ResetPlayer();
    }
	
	 //Reset the lost kitten
	private void ResetLostKitten()
	{
        transform.position = startPos;
        target = firstWayPointNode;
        steeringForce = Vector3.zero;
        steering.Speed = 0;
	}
	
	//Reset player and lost kittens that follow the player
	private void ResetPlayer()
	{
		//Reset the player
        player.transform.position = new Vector3(transform.position.x, 
			transform.position.y, 
			transform.position.z - PLAYER_STARTING_POSITION_OFFSET);
        player.Speed = 0;
        player.SteeringForce = Vector3.zero;
		
		//Check to see if the player has followers
		if(player.Followers.Count > 0)
		{
			//Reset them to their respective behind point
			foreach(LostKitten lostKitten in player.Followers)
			{
				if(lostKitten.catFollowerLeader == null)
				{
					lostKitten.transform.position = player.BehindPoint.transform.position;
				}
				else
				{
					lostKitten.transform.position = lostKitten.catFollowerLeader.BehindPoint.transform.position;
				}
				lostKitten.steering.Speed = 0;
				lostKitten.steeringForce = Vector3.zero;
			}
		}
	}
	
	//Reset Lost Kitten in the case senario that the player
	//is chasing another lost kitten after trying to attempt to
	//chase this one
	
	
	private void ClampSteering ()
	{
		if (steeringForce.magnitude > steering.maxForce) 
		{
			steeringForce.Normalize ();
            steeringForce *= steering.maxForce;
		}
	}
	
	// Update is called once per frame
	public void Update ()
	{
		CalcSteeringForce ();
		ClampSteering ();
		
		moveDirection = transform.forward * steering.Speed;
		// movedirection equals velocity
		
		// add acceleration modified for dt
		moveDirection += steeringForce * Time.deltaTime;

		//update speed to match the accelerated moveDirection
		steering.Speed = moveDirection.magnitude;

        // only perform this math if we've actually changed speed?
		if (steering.Speed != moveDirection.magnitude) 
        {
			moveDirection = moveDirection.normalized * steering.Speed;
		}

		//orient transform
        if (moveDirection != Vector3.zero)
        {
            transform.forward = moveDirection;
        }
            // yes, assigning .forward does automatically normalize
		
		// Apply gravity
        // this keeps us stuck on or beneath the ground
        // the CharacterController will make sure we stay above the terrain
		moveDirection.y -= gravity;
		// the CharacterController moves us subject to physical constraints
		characterController.Move(moveDirection * Time.deltaTime);
		
	}


	private void CalcSteeringForce ()
	{
		steeringForce = Vector3.zero;
		if(isVisible)
		{
			//Enable different modes based on the situation
			//Seek Mom Cat once the player has captured all of the lost kittens and has 
			//collided with the Mom Cat
			if(returnedToMomCat)
			{
				seekMomCatMode();
			}
			else
			{
				//Seek waypoint if the kitten has not been captured - path following
				float distanceBetweenThisAndPlayer = Vector3.Distance(transform.position, player.transform.position);
		        if (!capturedByPlayer && distanceBetweenThisAndPlayer < MINIMUM_DISTANCE || isSearchingForWayPoint)
		        {
					//Make search mode on to ensure the lost kitten keeps chasing
					//way points even if it is farther away from the player now
					if(!isSearchingForWayPoint)
					{
						isSearchingForWayPoint = true;
						player.ChasingLostKitten = this;
					}
					//Make sure the player isn't chasing another lost kitten
					if(player.ChasingLostKitten != this)
					{
						isSearchingForWayPoint = false;
						ResetLostKitten();
					}
					else
					{
		            	seekWayPointMode();
					}
		        }
				//Seek appropriate behind point and do arrival when close - leader following single line
		        else if(capturedByPlayer)
		        {
					leaderFollowerMode();
		        }
			}
		}

        // biggest difference?
        // not returning steeringForce
        // instead saving it to a persistant field
        // this is a stylistic choice
	}
	
	//Different modes
	//Seek waypoint mode
	private void seekWayPointMode()
	{
		steeringForce += seekWt * SeekWayPoint();
		//Avoid obstacles which are the trees
		steeringForce += avoidWt * AvoidObstacle();
	}
	//Leader follower mode
	private void leaderFollowerMode()
	{
		//Avoid the tree if the lost kitten is close to colliding with it
		steeringForce += avoidWt * AvoidObstacle();
		//Seek the appropirate behind point
		steeringForce += seekWt * SeekBehindPoint();
		//Align with the player
		steeringForce += alignmentWeight * steering.AlignTo(player.FlockDirection);
		
		//Use arrival to gradually slow down the speed
		//until it arrives at the appropriate behind point
		if(catFollowerLeader == null)
		{
			Arrival (player.gameObject, true);
		}
		else
		{
			Arrival (catFollowerLeader.gameObject, false);
		}
	}
	//Seek Mom Cat mode
	private void seekMomCatMode()
	{
		steeringForce += seekWt * steering.Seek(momCat.transform.position);
	}

    //Steering forces
	private Vector3 SeekWayPoint()
	{
		return steering.Seek (target.transform.position);
	}
	
	private Vector3 SeekBehindPoint()
	{
		//Seek the player's behind point
		if(catFollowerLeader == null)
		{
    		return steering.Seek(player.BehindPoint.transform.position);
		}
		//Otherwise seek the lost kitten in front of it's behind point
		else
		{
			return steering.Seek(catFollowerLeader.BehindPoint.transform.position);
		}
	}
	
	
	//Clamp the speed when close to the behind point
	private void Arrival(GameObject ownerOfBehindPointToChase, bool isPlayer)
	{
		//Find the distance between the player and the lost kitten
		float radiusOfBehindObjectToChase;
		float distanceBetweenThisAndBehindPoint;
		if(isPlayer)
		{
			radiusOfBehindObjectToChase = player.RadiusOfBehindObject;
			distanceBetweenThisAndBehindPoint = Vector3.Distance(transform.position, player.BehindPoint.transform.position);
		}
		else
		{
			radiusOfBehindObjectToChase = BehindPointRadius;
			distanceBetweenThisAndBehindPoint = Vector3.Distance(transform.position, catFollowerLeader.BehindPoint.transform.position);
		}
					
        //If it is in the radius of the player, then make the speed eventually slow down to zero
        if (distanceBetweenThisAndBehindPoint < radiusOfBehindObjectToChase)
        {
			//Slow the speed down gradually
			steering.Speed *= (distanceBetweenThisAndBehindPoint/radiusOfBehindObjectToChase);
        }
		else
		{
			//Debug.Log(steering.Speed);
			//steering.Speed = steering.maxSpeed;
			steeringForce += FullSpeedAhead();
		}
		//If it is really close to the behind point, then clamp the speed and steering force to zero
		if(distanceBetweenThisAndBehindPoint < 10)
		{
			steering.Speed = 0;
			steeringForce = Vector3.zero;
		}
	}
	
	//Avoid all obstacles if close enough
    private Vector3 AvoidObstacle()
    {
        Vector3 steeringForce = Vector3.zero;
        for (int i = 0; i < obstacles.Length; i++)
        {
            steeringForce += steering.AvoidObstacle(obstacles[i], avoidDist);
        }
        return steeringForce;
    }

    private Vector3 FullSpeedAhead()
    {
        Vector3 steeringForce;
        Vector3 desiredVelocity = transform.forward * steering.maxSpeed;
        steeringForce = desiredVelocity - steering.Velocity;
		desiredVelocity.y = 0;
        return steeringForce;
    }
	
}



